---
title:  SoC-NTM (T-DNC/NTM-SoC)
author: QueenField
geometry: "left=3cm,right=2cm,top=3cm,bottom=2cm"
---

# 0. INTRODUCTION

## 0.0. DO-254

### 0.0.1. HARDWARE PLANNING PROCESS
#### 0.0.1.1. Plan for Hardware Aspects of Certification
#### 0.0.1.2. Hardware Design Plan
#### 0.0.1.3. Hardware Validation Plan
#### 0.0.1.4. Hardware Verification Plan
#### 0.0.1.5. Hardware Configuration Management Plan
#### 0.0.1.6. Hardware Process Assurance Plan
### 0.0.2. HARDWARE DESIGN PROCESS
#### 0.0.2.1 Requirements Capture Process
#### 0.0.2.2 Conceptual Design Process
#### 0.0.2.3 Detailed Design Process
#### 0.0.2.4 Implementation Process
#### 0.0.2.5 Production Transition Process
### 0.0.3. VALIDATION AND VERIFICATION PROCESS
#### 0.0.3.1 Validation Process
#### 0.0.3.2 Verification Process
### 0.0.4. CONFIGURATION MANAGEMENT PROCESS
### 0.0.5. PROCESS ASSURANCE
### 0.0.6. CERTIFICATION LIAISON PROCESS
### 0.0.7. HARDWARE DESIGN LIFECYCLE DATA
#### 0.0.7.1 Certification Authority
#### 0.0.7.2 Certification Reviews
#### 0.0.7.3 Scheduling of Reviews
### 0.0.8. ADDITIONAL CONSIDERATIONS
#### 0.0.8.1 Previously Developed Hardware
#### 0.0.8.2 Commercial Components Usage

## 0.1. BEST PRACTICES

### 0.1.1. HARDWARE
### 0.1.2. SOFTWARE

# 1. METHODOGY

## 1.1. Requirements

### 1.1.1. Structural UML diagrams

#### 1.1.1.1. Class diagram
#### 1.1.1.2. Component diagram
#### 1.1.1.3. Composite diagram
#### 1.1.1.4. Deployment diagram
#### 1.1.1.5. Object diagram
#### 1.1.1.6. Package diagram
#### 1.1.1.7. Profile diagram

### 1.1.2. Behavioral UML diagrams

#### 1.1.2.1. Activity diagram
#### 1.1.2.2. Communication diagram
#### 1.1.2.3. Interaction diagram
#### 1.1.2.4. Sequence diagram
#### 1.1.2.5. State diagram
#### 1.1.2.6. Timing diagram
#### 1.1.2.7. Use diagram

## 1.2. Source

### 1.2.1. Ada Language
### 1.2.2. C Language

## 1.3. Model

### 1.3.1. VHDL
### 1.3.2. Verilog

## 1.4. Validation

### 1.4.1. VHDL
### 1.4.2. Verilog

## 1.5. Design

### 1.5.1. VHDL
### 1.5.2. Verilog

## 1.6. Verification

### 1.6.1. OSVVM-VHDL

#### 1.6.1.1. OSVVM Checker
#### 1.6.1.2. OSVVM Stimulus
#### 1.6.1.3. OSVVM Testbench

### 1.6.2. UVM-Verilog

#### 1.6.2.1. UVM Agent
#### 1.6.2.2. UVM Driver
#### 1.6.2.3. UVM Enviroment
#### 1.6.2.4. UVM Monitor
#### 1.6.2.5. UVM Scoreboard
#### 1.6.2.6. UVM Sequence
#### 1.6.2.7. UVM Sequencer
#### 1.6.2.8. UVM Subscriber
#### 1.6.2.9. UVM Test
#### 1.6.2.10. UVM Testbench
#### 1.6.2.11. UVM Transaction

# 2. PROJECTS

## 2.1. Mechanics

## 2.2. Information

### 2.2.1. Bit

### 2.2.2. Logic Gate

#### 2.2.2.1. YES/NOT Gate

#### 2.2.2.2. AND/NAND Gate

#### 2.2.2.3. OR/NOR Gate

#### 2.2.2.4. XOR/XNOR Gate

### 2.2.3. Combinational Logic

#### 2.2.3.1. Arithmetic Circuits

#### 2.2.3.2. Logic Circuits

### 2.2.4. Finite State Machine

### 2.2.5. Pushdown Automaton

## 2.3. Neural Network

### 2.3.1. Feedforward Neural Network

### 2.3.2. Long Short Term Memory Neural Network

### 2.3.3. Transformer Neural Network

## 2.4. Turing Machine

### 2.4.1. Neural Turing Machine

#### 2.4.1.1. Feedforward Neural Turing Machine

#### 2.4.1.2. LSTM Neural Turing Machine

#### 2.4.1.3. Transformer Neural Turing Machine

### 2.4.2. Differentiable Neural Computer

#### 2.4.2.1. Feedforward Differentiable Neural Computer

#### 2.4.2.2. LSTM Differentiable Neural Computer

#### 2.4.2.3. Transformer Differentiable Neural Computer

## 2.5. Computer Architecture

### 2.5.1. von Neumann Architecture

#### 2.5.1.1. Control Unit

#### 2.5.1.2. ALU

#### 2.5.1.3. Memory Unit

#### 2.5.1.4. I/O Unit

### 2.5.2. Harvard Architecture

#### 2.5.2.1. Control Unit

#### 2.5.2.2. ALU

#### 2.5.2.3. Memory Unit

#### 2.5.2.4. I/O Unit

## 2.6. Advanced Computer Architecture

### 2.6.1. Processing Unit

#### 2.6.1.1. SISD

#### 2.6.1.2. SIMD

#### 2.6.1.3. MISD

#### 2.6.1.4. MIMD

### 2.6.2. System on Chip

#### 2.6.2.1. Bus on Chip

#### 2.6.2.2. Network on Chip

### 2.6.3. Multi Processor System on Chip
